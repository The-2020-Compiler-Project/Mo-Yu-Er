# 符号表

##  1.符号表结构
### 1.1单词表的定义
```c
/* 单词存储结构定义 */
typedef struct TkWord
{
    int  tkcode;					// 单词编码 
    struct TkWord* next;			// 指向哈希冲突的其它单词
    char* spelling;					// 单词字符串 
    struct Symbol* sym_struct;		// 指向单词所表示的结构定义
    struct Symbol* sym_identifier;	// 指向单词所表示的标识符
} TkWord;

#define MAXKEY	1024				// 哈希表容量
```
单词表采用哈希表的存储结构，采用链地址法解决冲突。表中的每一个结点就是词法分析生成的Token值，这其中`tkcode`是该标识符在动态数组中的下标值，`spelling`是标识符的名字，`sym_struct`指向标识符的结构定义，比如该标识符为函数标识符，则`sym_struct`指向该函数的结构定义表相当于下面的Fun的Type，`sym_identifier`则指向下面的Symbol
### 1.2符号表的定义
```c
/* 类型存储结构定义 */
typedef struct Type
{
    int t;
    struct Symbol* ref;
} Type;

/* 符号存储结构定义 */
typedef struct Symbol
{
    int v;						// 符号的单词编码
    int r;						// 符号关联的寄存器
    int c;						// 符号关联值如结构体的大小，变量的偏移量
    Type type;					// 符号类型
    struct Symbol* next;		// 关联的其它符号，结构体定义关联成员变量符号，函数定义关联参数符号
    struct Symbol* prev_tok;	// 指向前一定义的同名符号
} Symbol;
```
这其中，`Type`内的`t`为`int`类型，表示类型编码，`ref`是一个`symbol`类型的指针，指向该标识符的实际存储结构，`Symbol`中`v`是单词的编码，单词存储在单词表中，单词表中放置标识符，包括变量名,函数名,结构定义名，单词表是一个动态数组，`v`就是标识符类型编码和该标识符在动态数组中下标值经过与运算的结果。`r`在之后的链接过程中会用到，`Type`是标识符的类型结构体；next指针指向与该标识符有关的其它符号，比如如果是函数名标识符则next指向参数标识符等；`prev_tok`指向前一个同名的符号。`c`表示结构体的size或者变量的偏移量，在整个项目里，假定`short`占用2字节，`int`占用4字节，`char/function/void`占用1字节，指针类型占用4字节。
### 1.3动态栈的定义

原本符号表结构我采用符号表主表使用哈希表存储，其余各表如(结构体表，数组表)使用链表存储，这样定义的好处是符号表的结构直观明了，但是在实际使用起来的时候需要定义大量的全局变量，同时对不同的表的维护十分麻烦，同时无法有效解决同名变量不同作用域的问题，经过查阅资料后，我选择使用动态栈来对符号表进行存储，利用栈后进先出的特点，在每一个单元块结束后，将该单元块内定义的局部变量出栈，对于不同作用域的同名变量就可以很方便的进行管理
```c
typedef struct Stack
{
    void** base;	// 栈底指针
    void** top;		// 栈顶指针
    int stacksize;	// 栈当前可使用的最大容量,以元素为单位
} Stack;
```
栈定义中，使用了void**类型，这样栈指针就可以指向任意一种类型的数据，同时栈指针是一个二重指针，这样*top就是一个数组，在它之前加上(type *)强制转换类型，就可以指向不同的数据类型，表示不同类型的数组。比如`(Symbol *)stack.top[5]`就是一个Symbol类型的数组，这样就可以很方便的存储不同作用域的标识符。

### 1.4接口声明
```c
//用于查找结构定义 v为符号编号
Symbol* struct_search(int v);
//用于查找标识符定义 v为符号编号
Symbol* sym_search(int v);	  
 /* 
  功能:	将符号放在符号栈中
  v:		符号编号
  type:	符号数据类型
  c:		符号关联值
  */
Symbol* sym_direct_push(Stack* ss, int v, Type* type, int c);
 /* 
  功能:	将符号放在符号栈中,动态判断是放入全局符号栈还是局部符号栈
  v:		符号编号
  type:	符号数据类型
  r:		符号存储类型
  c:		符号关联值
  */
Symbol* sym_push(int v, Type* type, int r, int c);
 /*
  功能:	将函数符号放入全局符号表中
  v:		符号编号
  type:	符号数据类型
  */
Symbol* func_sym_push(int v, Type* type);
 /*
  功能:	将函数的参数放入符号栈中，动态判断是放入全局符号栈还是局部符号栈
  v:		符号编号
  type:		符号数据类型
  r:		符号存储类型
  addr:		符号关联值
  */
Symbol* var_sym_put(Type* type, int r, int v, int addr)

```
### 1.5工作小结
截至星期四(7.2)，我完成了符号表的结构定义和实现符号表所需要的动态栈以及单词表，并且动态栈的所有操作函数都已经完成实现，现在正在努力地写上述接口函数，完成接口函数的实现后，根据工作进度可以考虑一下语义合法性检查，比如
```c
int a()
{
  x=1;
}
```
将会报错，提示x未定义。
这些功能都需要在完成符号表的基础上才能实现。这一个星期中，最让我印象深刻的是使用动态栈存储符号表，还有引入了void**这样的巧妙操作。
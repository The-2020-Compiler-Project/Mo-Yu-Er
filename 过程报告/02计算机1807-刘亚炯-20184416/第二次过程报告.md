###  1.6 符号表插入接口实现
```c
/*
 功能:	查找结构定义
 v:		符号编号,即动态数组的下标值
 */
Symbol* struct_search(int v)
{
    if (v >= tktable.count)
        return NULL;
    else
        return ((TkWord*)tktable.data[v])->sym_struct;
}
/*
 功能:	查找标识符定义
 v:		符号编号
 */
Symbol* sym_search(int v)
{
    if (v >= tktable.count)
        return NULL;
    else
        return ((TkWord*)tktable.data[v])->sym_identifier;
}
/*
 功能:	将符号放在符号栈中
 ss:	栈的类型，全局栈或者是局部栈
 v:		符号编号
 type:	符号数据类型
 c:		符号关联值，一般情况下为0，但在存在函数调用或者声明时会赋一个值
 */
Symbol* sym_direct_push(Stack* ss, int v, Type* type, int c)
{
    Symbol s, * p;
    s.v = v;
    s.type.t = type->t;
    s.type.ref = type->ref;
    s.c = c;
    s.next = NULL;
    p = (Symbol*)stack_push(ss, &s, sizeof(Symbol));
    return p;
}
/*
 功能:	将符号放在符号栈中,动态判断是放入全局符号栈还是局部符号栈
 v:		符号编号
 type:	符号数据类型
 r:		符号存储类型
 c:		符号关联值
*/
//注意：动态数组里面只存储结构体名，函数名等，然后使用动态数组内的成员sym_struct指向结构体的定义，或者使用sym_identifier指向函数之类的定义，并且这两个指针只能有一个被使用
Symbol* sym_push(int v, Type* type, int r, int c)
{
    Symbol* ps, ** pps;
    TkWord* ts;
    Stack* ss;

    if (stack_is_empty(&local_sym_stack) == 0)
    {
        ss = &local_sym_stack;
    }
    else
    {
        ss = &global_sym_stack;
    }
    ps = sym_direct_push(ss, v, type, c);
    ps->r = r;

    // 不记录结构体成员及匿名符号
    if ((v & SC_STRUCT) || v < SC_ANOM)
    {
    // 更新单词sym_struct或sym_identifier字段，对于结构体符号，结构体成员变量，函数形参等它们的v值是动态数组下标和存储类型进行或操作后的值。这样便于判断它们的存储类型
        ts = (TkWord*)tktable.data[(v & ~SC_STRUCT)];
        if (v & SC_STRUCT)	
            pps = &ts->sym_struct;
        else
            pps = &ts->sym_identifier;
        ps->prev_tok = *pps;//指向上一个同名符号;
        *pps = ps;
    }
    return ps;
}
/*
 功能:	弹出栈中符号直到栈顶符号为'b'
 ptop:	符号栈栈顶
 b:		符号指针
 便于在函数定义结束后清空栈，因为在每一个函数声明时都会存入一个匿名符号，在定义结束后一直弹出到栈顶符号为匿名符号。
 */
void sym_pop(Stack* ptop, Symbol* b)
{
    Symbol* s, ** ps;
    TkWord* ts;
    int v;

    s = (Symbol*)stack_get_top(ptop);
    while (s != b)
    {
        v = s->v;
        // 更新单词表中sym_struct sym_identifier
        if ((v & SC_STRUCT) || v < SC_ANOM)
        {
            ts = (TkWord*)tktable.data[(v & ~SC_STRUCT)];
            if (v & SC_STRUCT)
                ps = &ts->sym_struct;
            else
                ps = &ts->sym_identifier;
            *ps = s->prev_tok;
        }
        stack_pop(ptop);
        s = (Symbol*)stack_get_top(ptop);
    }
}
```
除此之外还有生成指针，返回类型长度，和函数声明，定义的插入函数。这里就不一 一写出了，具体请看代码文件。
# 语义分析
已经实现了按照开始定义的文法，对过滤后的源程序进行语义分析，然后将源程序中出现的符号插入符号表，并检查有无语义错误，如果有，则在对应位置提示错误。
目前已经实现的有结构体，函数，运算表达式，声明，类型区分，各种语句(包括if,for,break,return,continue等)
的语义分析，因为代码量实在太大，所以具体情况请参考代码文件。






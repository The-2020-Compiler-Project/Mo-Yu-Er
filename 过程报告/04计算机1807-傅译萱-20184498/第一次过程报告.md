+ # 第一次报告

  ## 词法分析主要任务
  
  + 识别单词
  
    从用户的源程序中把单词分离出来
  
  + 翻译单词
  
    把单词转换成机内表示，便于后续处理
  
  ## 单词编码
  
  ​	为了更便利地操作管理单词，对单词进行编号处理为了方便记忆，列表如下：
  
  + 单词编码表
  
  | 词法记号类型标识 | 含义 | 词法记号类型标识 | 含义          |
  | ---------------- | ---- | ---------------- | ------------- |
  | TK_PLUS          | "+"  | TK_COMMA         | ","           |
  | TK_MINUS         | "-"  | TK_ELLIPSIS      | "..."         |
  | TK_STAR          | "*"  | TK_EOF           | "End_Of_File" |
  | TK_DIVIDE        | "/"  | TK_CINT          | "整型常量"    |
  | TK_MOD           | "%"  | TK_CCHAR         | "字符常量"    |
  | TK_EQ            | "==" | TK_CSTR          | "字符串常量"  |
  | TK_NEQ           | "!=" | KW_CHAR          | "char"        |
  | TK_LT            | "<"  | KW_SHORT         | "short"       |
  |                  | "<=" | KW_INT           | "int"         |
  | TK_GT            | ">"  | KW_VOID          | "void"        |
  | TK_GEQ           | ">=" | KW_STRUCT        | "struct"      |
  | TK_ASSIGN        | "="  | KW_IF            | "if"          |
  | TK_POINTSTO      | "->" | KW_ELSE          | "else"        |
  | TK_DOT           | "."  | KW_FOR           | "continue"    |
  | TK_AND           | "&"  | KW_CONTINUE      | "continue"    |
  | TK_OPENPA        | "("  | KW_BREAK         | "break"       |
  | TK_CLOSEPA       | ")"  | KW_RETURN        | "return"      |
  | TK_OPENBR        | "["  | KW_SIZEOF        | "sizeof"      |
  | TK_CLOSEBR       | "]"  | KW_ALIGN         | "__align"     |
  | TK_BEGIN         | "{"  | KW_CDECL         | "__cdecl"     |
  | TK_END           | "}"  | KW_STDCALL       | "__stdcall"   |
  | TK_SEMICOLON     | ";"  |                  |               |
  
  + 单词编码
  
    ```c
    enum eTokenCode
    {
        /* 运算符及分隔符 */
        TK_PLUS,		// + 加号
        TK_MINUS,		// - 减号
        TK_STAR,		// * 星号
        TK_DIVIDE,		// / 除号
        TK_MOD,			// % 求余运算符
        TK_EQ,			// == 等于号
        TK_NEQ,			// != 不等于号
        TK_LT,			// < 小于号
        TK_LEQ,			// <= 小于等于号
        TK_GT,			// > 大于号
        TK_GEQ,			// >= 大于等于号
      TK_ASSIGN,		// = 赋值运算符 
        TK_POINTSTO,	// -> 指向结构体成员运算符
        TK_DOT,			// . 结构体成员运算符
        TK_AND,         // & 地址与运算符
        TK_OPENPA,		// ( 左圆括号
        TK_CLOSEPA,		// ) 右圆括号
        TK_OPENBR,		// [ 左中括号
        TK_CLOSEBR,		// ] 右圆括号
        TK_BEGIN,		// { 左大括号
        TK_END,			// } 右大括号
        TK_SEMICOLON,	// ; 分号    
        TK_COMMA,		// , 逗号
        TK_ELLIPSIS,	// ... 省略号
        TK_EOF,			// 文件结束符
    
        /* 常量 */
        TK_CINT,		// 整型常量
        TK_CCHAR,		// 字符常量
        TK_CSTR,		// 字符串常量
    
        /* 关键字 */
        KW_CHAR,		// char关键字
        KW_SHORT,		// short关键字
        KW_INT,			// int关键字
        KW_VOID,		// void关键字  
        KW_STRUCT,		// struct关键字   
        KW_IF,			// if关键字
        KW_ELSE,		// else关键字
        KW_FOR,			// for关键字
        KW_CONTINUE,	// continue关键字
        KW_BREAK,		// break关键字   
        KW_RETURN,		// return关键字
        KW_SIZEOF,		// sizeof关键字
    
        KW_ALIGN,		// __align关键字	
        KW_CDECL,		// __cdecl关键字 standard c call
        KW_STDCALL,     // __stdcall关键字 pascal c call
    
        /* 标识符 */
        TK_IDENT
    };
    
    ```
  
    ## 使用的数据结构
  
    ### 动态字符串
  
    + C语言字符串是以字符数组表示的，并以‘\0’结尾，C语言标准库提供了很多函数来操作此类型的字符串，但这些函数可能并不安全，可能会引发一系列问题，既为了使数据结构支持动态扩展，又可以避免缓冲区溢出，因此使用了地方字符串。
  
    * 动态字符定义
  
    ```c
    typedef struct DynString
    {
    	int count;		//字符串的长度
    	int capacity;	//缓冲区容量
    	char* str;		//字符串指针
    }DynString;
    ```
  
    * 源程序代码
  
      ```c
      #include "DynString.h"
      #include <stdio.h>
      #include <stdlib.h>
      void str_init(DynString* pstr, int init_size)//初始化
      {
      	if (pstr != NULL)
      	{
      		pstr->count = 0;
      		pstr->capacity = init_size;
      		pstr->str = (char*)malloc(sizeof(char) * init_size);
      	}
      }
      
      void str_free(DynString* pstr)//释放内存
      {
      	if (pstr != NULL)
      	{
      		pstr->count = 0;
      		pstr->capacity = 0;
      		if (pstr->str != NULL)
      		{
      			free(pstr->str);
      		}
      	}
      }
      
      void str_cat(DynString* pstr, char ch)//追加单个字符到动态字符串对象
      {
      	pstr->count += 1;
      	if (pstr->count > pstr->capacity)
      	{
      		str_realloc(pstr, pstr->count);
      	}
      	pstr->str[pstr->count - 1] = ch;
      }
      
      void str_print(DynString* pstr)
      {
      	for (int i = 0; i < pstr->count; i++)
      	{
      		printf("%c", pstr->str[i]);
      	}
      }
      
      void str_realloc(DynString* pstr, int new_size)//重新分配字符串容量
      {
      	int capacity = pstr->capacity;
      	char* str;
      	/* 成倍扩展,若每次拓展一个,重复调用realloc,造成浪费 */
      	while (capacity < new_size)
      	{
      		capacity *= 2;
      	}
      	str = realloc(pstr->str, capacity);
      	if (str == NULL)
      	{
      		//错误处理
      		//error("内存分配失败");
      	}
      	pstr->capacity = capacity;
      	pstr->str = str;
      }
      
      void str_reset(DynString* pstr)
      {
      	str_free(pstr);
      	str_init(pstr, 16);
      }
      
      ```
  
      
  
  ### 动态数组
  
  + 动态数组定义
  
    ```c
    typedef struct DynArray
    {
    	int count;		//当前元素个数
    	int capacity;	//缓冲区长度(最多能承载的元素个数)
    	void** data;	//指针数组,使用void*便于抽象封装
    }DynArray;
    ```
  
  + 源程序代码
  
  ```c
  #include "DynArray.h"
  #include <stdlib.h>
  void array_init(DynArray* parr, int init_size)//初始化动态数组
  {
  	if (parr)
  	{
  		parr->count = 0;
  		parr->capacity = init_size;
  		parr->data = (void**)malloc(sizeof(void*) * init_size);
  	}
  }
  
  void array_free(DynArray* parr)//释放动态数组使用的内存空间
  {
  	if (parr)
  	{
  		void** p;
  		parr->capacity = 0;
  		for (p = parr->data; parr->count != 0; --parr->count, ++p)
  		{
  			if (*p)
  			{
  				free(*p);
  				*p = NULL;
  			}
  		}
  		parr->data = NULL;
  	}
  }
  
  void array_push(DynArray* parr, void* data)
  {
  	parr->count += 1;
  	if (parr->count > parr->capacity)
  	{
  		array_realloc(parr, parr->count);
  	}
  	parr->data[parr->count - 1] = data;
  
  }
  
  void array_pop(DynArray* parr)
  {
  	parr->count -= 1;
  	parr->data[parr->count] = NULL;
  }
  
  int array_search(DynArray* parr, int key)//动态数组元素查找
  {
  	int** p = (int**)parr->data;
  	for (int i = 0; i < parr->capacity; i++, p++)
  	{
  		if (**p == key)
  		{
  			return i;
  		}
  	}
  	return -1;
  }
  
  void array_realloc(DynArray* parr, int new_size)//重新分配动态数组容量
  {
  	int capacity = parr->capacity;
  	void* data;
  	while (capacity < new_size)
  	{
  		capacity *= 2;
  	}
  	data = realloc(parr->data, capacity * sizeof(void*));
  	if (!data)
  	{
  		//错误处理
  	}
  	parr->capacity = capacity;
  	parr->data = data;
  }
  
  ```
  
  
  
  
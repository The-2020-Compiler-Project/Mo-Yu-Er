## COFF文件格式学习

- 一个COFF文件头大小为20字节
- 每个节头40字节
- 每一个符号表的纪录是18个字节，需要取消结构体字节对齐。



> 为什么需要字节对齐？

计算机组成原理教导我们这样有助于加快计算机的取数速度，否则就得多话指令周期了。为此，编译器默认会对结构体进行处理（实际上其它地方的数据变量也是如此），让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度为4的基本数据类型（int等）都位于能被4整除的地址上，以此类推。这样，两个数中间就可能需要加入填充字节，所以整个结构体的sizeof值就增长了。

```c
#pragma pack(push, 1)	//将原来的字节对齐方式压栈，对齐方式改为1字节对齐，也就是取消字节对齐

#pragma pack(pop) //恢复原来的字节对齐方式
```



> 什么是字节序？

也就是小端和大端的意思，大端是高地址存放高字节，低地址存放低字节。小端是高地址存放高字节，低地址存放低字节。我们使用的是小端模式。

> 怎么区分是前缀指令还是操作码？

直接查表，查到是操作码就是操作码，是指令前缀就是指令前缀，是前缀指令就继续往下查操作码

可以加多个（最多四个）指令前缀，每个指令前缀一个字节。每个指令前缀都应该与其他指令前缀保持类别不同。



# X86机器语言

## 通用指令格式

指令前缀+操作码+ModR/M+SIB字节+偏移量+立即数



## 指令前缀

- 操作数长度前缀
- 地址长度前缀
- 段超越前缀
- 重复前缀
- 锁定前缀



## 操作码

定长指令：操作码后面不跟ModR/M和SIB

不定长指令：操作码后面跟ModR/M，也可能跟SIB

操作码1-3字节（不算上后面的ModR/M和SIB)

大于1字节的，去后面的字节去2byte表去查



## ModR/M字节

- Mod:ModRM[7:6]
- Reg：ModRM[5:3]
- R/M部分：ModRM[2:0]

Reg用来找是寄存器的那一个操作数，因为两个操作数不可能都是内存。Mod和R/M一起来找剩下的操作数。



## SIB字节

如果ModR/M找到的内容是\[--][--]+(disp)，则需要查找SIB，来确定操作数的寻址方式。[base + 寄存器*sc + (disp)]，如果有disp的话